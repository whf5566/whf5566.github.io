<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2017 on Wellphone&#39;s Blog</title>
    <link>https://wellphone.me/categories/2017/index.xml</link>
    <description>Recent content in 2017 on Wellphone&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <atom:link href="/categories/2017/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>腾讯Bugly的巨坑：使用不当会造成UI界面卡死</title>
      <link>https://wellphone.me/post/2017/bugly_dispatch_once_crash/</link>
      <pubDate>Fri, 25 Aug 2017 16:52:20 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/bugly_dispatch_once_crash/</guid>
      <description>前言 Bugly和dispatch_once使用不当，会造成UI界面卡死。笔者在前段时间碰见了这样的一个卡死的情况，特意记录下来。
iOS开发者或多或少都听过或用过Bugly。它是腾讯开发的一个SDK，用来捕捉App中的crash。对于dispatch_once大家就更熟悉了，现在大部分开发者用这个来创建单例。如：
+ (SingletonA *)sharedInstance { static SingletonA *_singleton = nil; static dispatch_once_t once; dispatch_once(&amp;amp;once, ^{ _singleton = [[SingletonA alloc] init]; }); return _singleton; }  但是这两个在一起怎么会造成UI界面卡死呢？如果笔者不是亲眼所见，也不会相信Bugly会造成界面卡死。
现象 前几天碰见了这样一个情况，我们的App启动时有时候会卡在启动界面上，过一段时间 就会被系统杀掉，而且不会有Crash的堆栈。这个现象让我们开发很头疼，一旦出现就只能杀进程，重新启动App，并且还不知道是怎么回事。
调查 看到界面卡死的第一反应就是，是不是哪个地方死锁导致主线程阻塞了。使用Console.app查看App启动时的日志，没发现什么异常的情况，并且死锁这个在日志中查找起来比较麻烦。
好不容易复现这个情况后，赶紧把手机接上Mac，在Xcdoe中Attach我们App的进程，如图：
然后暂停下App进程，就可以看到当前所有线程的堆栈情况了。如图：
这下，我们才知道是卡在了dispatch_once这个地方。是我们的单例使用有问题吗？我们知道， 如果dispatch_once递归调用就会产生死锁。示例代码如下：
+ (SingletonA *)sharedInstance { static SingletonA *_singleton = nil; static dispatch_once_t once; dispatch_once(&amp;amp;once, ^{ _singleton = [[SingletonA alloc] init]; }); return _singleton; } - (instancetype)init { self = [super init]; if (self) { [self somethingInit]; // 这个方法里也调用了[SingletonA sharedInstance]，所以会产生死锁 } return self; } - (void)somethingInit { [SingletonA sharedInstance]; }  很有可能就是这个原因导致我们的App启动时卡死。于是我们开始排查dispatch_once的代码里会不会在某个条件下再次调用到相同的dispatch_once，形成递归调用，导致死锁。</description>
    </item>
    
    <item>
      <title>iOS如何实时查看App运行日志</title>
      <link>https://wellphone.me/post/2017/how_to_view_app_log_on_mac/</link>
      <pubDate>Thu, 13 Jul 2017 09:42:08 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/how_to_view_app_log_on_mac/</guid>
      <description>前言 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 可能大数人看到这个标题觉得DEBUG时在Xcode里就能看到App运行时的打印在控制台里的日志，这还需要专门写篇文章介绍下吗？其实不然，有些场景下我们还是需要实时查看App运行时的日志的，比如测试人员拿着测试机发现问题了过来找你，这时候要看运行时日志，又不能重新DEBUG安装版本，怎么办？再比如，收到并点击推送的通知后启动App，这时候要查看我们打印的日志，怎么办？还有，弄过VoIP推送同学的都知道，这个推送可以直接启动我们的App，如果要观察启动过程中的日志，这该怎么办？总不能只能连着Xcode运行时，我们才能看到日志吧。有同学可能会说，把日志写入文件，启动完成后，再把文件拷贝出来看不就完了，好了，这篇文章你一定要认真看完。
查看日志的几种方式 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里我们说的日志是输出到控制台的日志，就是我们常用的NSLog输出的日志。其实大部分App会集成日志模块，比如CocoaLumberjack，还有以前笔者学习Runloop时也造过这样的轮子SSLogger。利用第三方日志模块查看日志不在本文讨论范围内，本文只讨论如何实时查看输出在console控制台的日志。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大致有以前几种方式查看日志，一种是连着Xcode调试时，可以直接在Xcode下面的控制台输出面板上看到我们App的日志。如图:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;还一种也是Xcode，通过Window-&amp;gt;Devices打开devices界面，选择我们的手机，也能看到手机中运行的进程输出的日志。如图：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上面这两种方式大部分iOS开发应该都知道，不知道的就该检讨下了。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文重点介绍另外两种查看运行时日志的方式： libimobiledevice 和 Console.app(控制台应用)
使用libimobiledevice工具查看日志 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;libimobiledevice 是一系列工具集，有很多实用的工具，截屏，安装ipa文件等等。我们要介绍的是idevicesyslog这个工具，这个工具可以把手机中的日志输出到我们指定的文件里。
 如何安装libimobiledevice
  安装libimobiledevice很简单，在命令行输入：
brew install libimobiledevice --HEAD  注意，需要加上 &amp;ndash;HEAD 选项，如果不加，安装是老版本，不支持iOS10的手机，所以安装时，需要加上 &amp;ndash;HEAD 选项, 如图:
如果电脑上没有brew，请看这里:brew安装传送门
 如何使用idevicesyslog
很简单，在命令行输入：
idevicesyslog  就可以在屏幕上看见手机上所有的日志了。  如何查看我们想要的日志
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1）将设备日志重定向到文件
idevicesyslog &amp;gt;&amp;gt; iphone.log &amp;amp;  该命令是将日志导入到iphone.log这个文件，并且是在后台执行。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2）用tail -f和grep查看log
tail -f iphone.log tail -f iphone.log | grep &#39;QQ’ # 查看包含QQ的行  如图：
使用Mac自带的控制台应用查看iOS日志 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在用过各种办法查看App日志后，还是觉得苹果系统自带的工具用起来最方便，不用安装，不用命令行，傻瓜式操作，非常方便。但是还有好多同学不知道怎么用，这里简单的给大家介绍下。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;连上手机，在LaunchPad其他文件中打开控制台应用，或者搜索Console.app打开控制台应用，可以看到左侧一栏中有我们的手机设备，选择就可以，如图
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;右侧输出的日志不仅有我们自己的App还有其他进程的日志，怎么过滤？非常简单，选中一条我们的日志，在进程名字上右键，选择显示进程名，然后就只会显示我们App的日志。如果显示的列名中没有进程名，我们可以在其他列名上右键，在弹出的菜单中勾选上进程就可以了。如图显示QQ打印出的日志：
日志还是有点多，看不清，怎么办，在右上方输入自己想要过滤出的日志，然后就会只显示你想要的，如图显示QQ打印出的日志中所有带有“***”的行</description>
    </item>
    
    <item>
      <title>为什么支付宝SDK不显示H5支付页面</title>
      <link>https://wellphone.me/post/2017/why_can_not_open_alipay_h5_webview/</link>
      <pubDate>Tue, 11 Jul 2017 11:16:30 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/why_can_not_open_alipay_h5_webview/</guid>
      <description>问题描述 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们的App集成有微信支付、支付宝支付，前段时间一直工作的很好。但是最近我们测试组发现支付宝支付就不能打开H5的支付页面了，会一直在如下界面等待：
问题排查 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先想到的是支付宝SDK集成出了问题。但是试了下，如果手机上安装有支付宝，会跳转到支付宝应用，支付成功或者手动取消返回都能正常的跳回我们的App。安装有支付宝应用的手机的支付流程是没有问题，能正常工作。可以排除支付宝SDK集成应该没有问题，但是为什么在没有安装支付宝应用的手机上，H5的支付页面显示不出来呢？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;是不是我们自己的页面上调用方法的原因？我们的支付下单页面也是一个web页面，native代码通过&amp;rdquo;WebViewJavascriptBridge&amp;rdquo; 这个库开了一个支付的接口给web页面调用。web页面调用alipay接口代码如下：
[bridge registerHandler:@&amp;quot;alipay&amp;quot; handler:^(id data, WVJBResponseCallback responseCallback) { NSLog(@&amp;quot;alipay called: %@&amp;quot;, data); // 调用支付宝接口支付 [AlipayUtil pay:data competion:^(PayResult reslut) { // 支付结果返回 responseCallback(@(result)); }]; }];  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们详细比对了整个流程中打印出的日志，完全看不出任何问题，但H5的支付页面就是不能显示出来。怎么办？现在只有查找提交记录，看是哪次提交引起的。最后发现是在合入我们自己的聊天SDK后，H5的支付页面就不能正常工作了。到这里，笔者开始怀疑人生了，我们的聊天SDK完全没有和支付宝相关的东西啊，为什么会这样？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;支付宝的H5支付页面也是一个webview，添加到我们的window之上的，会不会是没有显示，或者被挪到我们的view下面被盖住了？我们使用iOS自带悬浮窗调试工具使用详解中的View调试工具查看了一下，果然还是有些异常的：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们的App居然有两个window，选择另外一个window查看了一下，我靠，h5页面居然在这里：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;总算找到这个消失的H5支付页面了，那么问题来了，为什么集成聊天的SDK后，会有两个window？
问题定位 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;找到了消失的H5支付页面后，问题变得清晰起来，可以确定的是支付宝SDK集成没有问题，我们web页面调用的native支付接口没有问题，问题出在集成聊天SDK后，出现了两个window，而支付宝SDK在显示H5支付页面时，把页面添加到另外一个window上了。在查看聊天SDK源码后发现了问题所在：
self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; self.window.rootViewController = [NavigationController rootViewController];; [self.window makeKeyAndVisible];  在聊天SDK初始化时，有这几行代码，然后就有两个window了~~~~~</description>
    </item>
    
    <item>
      <title>iOS如何正确的监听手机侧边音量键</title>
      <link>https://wellphone.me/post/2017/how_to_monitor_volume_changes/</link>
      <pubDate>Sat, 08 Jul 2017 22:28:48 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/how_to_monitor_volume_changes/</guid>
      <description>如何监听手机侧边音量键 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们的App有这样一个Feature，用户通过音量键调节到最大音量时，会弹出一个Toast，提示 用户当前音量已经最大了，继续按音量上键可以设置为超大音量模式（通过调节音频文件的音量）。刚开始，我们在App中是监听名称为“AVSystemController_SystemVolumeDidChangeNotification”的系统通知来获知用户通过侧边音量键调节手机音量的事件。
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onVolumeChanged:) name:@&amp;quot;AVSystemController_SystemVolumeDidChangeNotification&amp;quot; object:nil];  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;处理该通知的方法如下：
- (void)onVolumeChanged:(NSNotification *)notification { if ([[notification.userInfo objectForKey:@&amp;quot;AVSystemController_AudioCategoryNotificationParameter&amp;quot;] isEqualToString:@&amp;quot;Audio/Video&amp;quot;]) { if ([[notification.userInfo objectForKey:@&amp;quot;AVSystemController_AudioVolumeChangeReasonNotificationParameter&amp;quot;] isEqualToString:@&amp;quot;ExplicitVolumeChange&amp;quot;]) { CGFloat volume = [[notification.userInfo objectForKey:@&amp;quot;AVSystemController_AudioVolumeNotificationParameter&amp;quot;] floatValue]; if (volume != MAX_VOLUME) { // todo } else { // todo } } } }  发现问题 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这段代码在我们这个App中工作的一直很好。但是最近一段时间，测试人员编译版本，有时音量调节到最大后，没有弹出Toast提示，而有时又会弹出来。经调试，发现有时候能监听到“AVSystemController_SystemVolumeDidChangeNotification”系统通知，有时候又没有，很飘忽不定。一时间大家都不知道怎么回事，很是头疼。因为这个代码在之前发布出去的正式版本中，从来没有出现过这样的问题。
定位问题 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以前版本没有，而现在的版本有，说明肯定是改出来的问题。只有checkout到之前的commit，逐一测试找出是哪次提交造成这样的问题。但是这样折腾了好久也没能定位到是哪次提交造成的。最后，折腾了一天，我们这边的一位美女同事Sharon最后解决了这个问题，她在stackoverflow上找到了类似的问题，发现是我们删除之前通过耳机线控App的一个Feature时，把这段代码删掉了造成的。而这段代码是开始监听远程控制事件。
[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Fuck！NSNotificationCenter监听的通知“AVSystemController_SystemVolumeDidChangeNotification”居然和RemoteControlEvents有关系，是因为耳机线上也有音量调节按键的原因？？？</description>
    </item>
    
    <item>
      <title>iOS自带悬浮窗调试工具使用详解</title>
      <link>https://wellphone.me/post/2017/use_uidebugginginformationoverlay_to_debug_ui/</link>
      <pubDate>Thu, 08 Jun 2017 09:58:10 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/use_uidebugginginformationoverlay_to_debug_ui/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前几天在博客上看到一篇文章《震惊！iOS 系统居然自带悬浮窗口调试工具》,看完之后笔者真就震惊了，有这样好的UI调试工具，苹果为什么不公开呢？笔者按照博文中的描述，在app中试了一下，感觉非常好用。
如何开启 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 AppDelegate 的 didFinishLaunchingWithOptions 方法中加入以下代码就可以了。
#if DEBUG id overlayClass = NSClassFromString(@&amp;quot;UIDebuggingInformationOverlay&amp;quot;); [overlayClass performSelector:NSSelectorFromString(@&amp;quot;prepareDebuggingOverlay&amp;quot;)]; #endif  运行后，用两个手指头在状态栏上同时点击下就可以显示出这个调试的悬浮层。
悬浮窗主界面 可以看到大概有这样几个选项，
 View Hierarchy（查看View的层级关系）
 VC Hierarchy（查看ViewController层级关系）
 Ivar Explorer（查看UIApplication 的成员属性）
 Measure （测量View的尺寸）
 Spec Compare （对比设计图）
  View Hierarchy &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 进入到这个页面后，可以看见整个view的层级结构。悬浮窗右上角有个Inspect，点击这个可以高亮显示当前选择的View。如图所示：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
当前选中的是 SettingSwitchItemView。
我们在页面上选择一个swicth按钮，这时会定位到该view的条目，如图所示：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
我们点击右侧的“！”图标，进入到swicth的详情页面，这里展示了view的详西信息，并且可以修改一些属性，比如我们修改这个button的透明度，如图所示：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
VC Hierarchy &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们回到悬浮窗的主界面，进入到VC Hierarchy界面看看。
这里是所有的VC的层级关系，一目了然。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
Ivar Explorer &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;接下来我们去Ivar Explorer页面看一下。进到页面后，对里面的一些值不是很熟悉，不知道是哪里的一些值，不过里面，看见了我们熟悉的 AppDelegate 。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</description>
    </item>
    
    <item>
      <title>使用Interface Builder开发界面</title>
      <link>https://wellphone.me/post/2017/autolayout_demo/</link>
      <pubDate>Wed, 03 May 2017 09:51:08 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/autolayout_demo/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前在公司内部分享会上，简单的分享了下如何使用Interface Builder开发iOS界面以及几种界面开发的方式的优缺点。写了一篇文章，现在直接把这篇文章贴到了blog上。
认识IB IB 即 Interface Builder ，是集成到Xcode上的iOS界面可视化开发工具。
功能面板  对象库面板
提供了所有Cocoa Touch 库给我们定义好的界面组件，包括 View 组件和 Controller 组件(所有名字带 xxxxController 的组件)。
对象库中组件较多，为了查找方便，底部提供了搜索栏，功能强大，一般只要输入关键的几个字母，就能快速找到你需要的组件。
 主界面
主界面提供了一个设计区域，该区域中放入我们设计的所有组件，一般要先放入一个容器组件，如：UIView 视图。然后在视图中放入其他组件。
为了快速查看主界面中相关信息，可以通过左侧的侧边栏(Desk)查看。
 属性面板
在主界面选中某个组件后，在该区域可以查看并设置组件的属性。
  示例 demo下载
 新增一个按钮
 新增一个table
 IBInspectable / IBDesignable
  Autoresizing 技术介绍 autoresizing是UIView的属性，可以用来做一些简单的自动布局实现。   属性 描述   UIViewAutoresizingNone 不会随父视图的改变而改变    UIViewAutoresizingFlexibleLeftMargin 自动调整view与父视图左边距，以保证右边距不变   UIViewAutoresizingFlexibleWidth 自动调整view的宽度，保证左边距和右边距不变    UIViewAutoresizingFlexibleRightMargin 自动调整view与父视图右边距，以保证左边距不变    UIViewAutoresizingFlexibleTopMargin 自动调整view与父视图上边距，以保证下边距不变   UIViewAutoresizingFlexibleHeight 自动调整view的高度，以保证上边距和下边距不变   UIViewAutoresizingFlexibleBottomMargin 动调整view与父视图的下边距，以保证上边距不变</description>
    </item>
    
    <item>
      <title>AirPods远程控制适配</title>
      <link>https://wellphone.me/post/2017/airpods_remote_controll/</link>
      <pubDate>Mon, 24 Apr 2017 09:59:57 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/airpods_remote_controll/</guid>
      <description>AirPods 16年底苹果推出了AirPods耳机。公司产品要适配AirPods，支持AirPods的远程控制。我在拿到耳机后，折腾了一会，连不上手机，竟然不知道怎么使用。～～～
上网找到了官方的使用方法：https://support.apple.com/zh-cn/HT207010
AirPods的远程控制默认是控制Siri和电话。快速施力轻点两下这个AirPod外侧可激活Siri或使用电话。这个不是我们App想要的远程控制，我们希望能通过AirPods来控制App的行为，即希望App能监听到AirPods的操作。在官方的使用说明中有这样一段话“如果您喜欢，您可以更改设置，使轻点两下时执行的操作变成播放或暂停音乐。”Ok，只要能双击播放，双击暂停音乐，那么App就能监听到远程控制事件，同线控耳机的那些远程控制事件一样。
下面是适配AirPods远程控制的一些小结。
AirPods在不同系统上的表现 AirPods在iOS10.2以下表现和普通的蓝牙耳机类似，能手动通过蓝牙连接上手机。
AirPods在iOS10.2以上的能支持双击操作，双击播放音乐，双击停止音乐；分别对应远程线控中的UIEventSubtypeRemoteControlPlay、UIEventSubtypeRemoteControlStop等事件。
如何监听远程控制事件：http://www.cnblogs.com/kenshincui/p/3950646.html#remoteControl
如何判断现在接入了AirPods 通过检查AVAudioSession的currentRoute中的输出port的名字，可以判断当前音频输出是否是AirPods
- (BOOL)isAirPods { NSArray&amp;lt;AVAudioSessionPortDescription *&amp;gt; *outputPorts = [AVAudioSession sharedInstance].currentRoute.outputs; for (AVAudioSessionPortDescription *desc in outputPorts) { if ([desc.portName rangeOfString:@&amp;quot;AirPods&amp;quot;].length &amp;gt; 0) { return YES; } } return NO; }  这个代码在iOS10以下的系统也能工作，在iOS10以下AirPods表现如同蓝牙耳机，并且，portName 还是AirPods。
如果需要用户在戴上耳机的时候检查是否是AirPods，可以监听系统发出的AVAudioSessionRouteChangeNotification通知，在route改变时，通过上面的代码检查下，就可以知道是否是用户带上了AirPods耳机。
有时，我们需要检查当前输出音频设备是否有蓝牙，也可以像上面的代码一样
- (BOOL)isBluetooth { NSArray&amp;lt;AVAudioSessionPortDescription *&amp;gt; *outputPorts = [AVAudioSession sharedInstance].currentRoute.outputs; for (AVAudioSessionPortDescription *desc in outputPorts) { if ([desc.portType isEqualToString:AVAudioSessionPortBluetoothA2DP] || [desc.portType isEqualToString:AVAudioSessionPortBluetoothLE] || [desc.portType isEqualToString:AVAudioSessionPortBluetoothHFP]) { return YES; } } return NO; }  AirPods的远程控制 这里说的AirPods远程控制，不是通过AirPods唤起Siri或者接系统电话，而是通过AirPods播放、停止音乐。 在连上AirPods后，需要在手机上进行设置，将AirPods的双击操作改成播放／停止音乐。具体设置方法见：https://support.</description>
    </item>
    
  </channel>
</rss>
