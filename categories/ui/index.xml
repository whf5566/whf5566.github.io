<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ui on Wellphone&#39;s Blog</title>
    <link>https://wellphone.me/categories/ui/</link>
    <description>Recent content in Ui on Wellphone&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Fri, 02 Mar 2018 19:05:20 +0800</lastBuildDate>
    <atom:link href="/categories/ui/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>搭建React Native开发环境</title>
      <link>https://wellphone.me/post/2018/setup_rn_dev_env/</link>
      <pubDate>Fri, 02 Mar 2018 19:05:20 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2018/setup_rn_dev_env/</guid>
      <description>搭建React Native开发环境 前言 最近公司决定在项目中引入React Native，然后我们就开始入坑React Native。我个人是不看好React Native，觉得React Native除了开发页面快，更新页面方便外，其他坑还是很多的。以下是从React Native中文文档摘抄来的安装步骤。
安装 Homebrew Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。
/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;  在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：
sudo chown -R `whoami` /usr/local  Node 使用Homebrew来安装Node.js.
brew install node  安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！
npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global  Yarn、React Native的命令行工具（react-native-cli） Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。
npm install -g yarn react-native-cli  安装完yarn后同理也要设置镜像源：
yarn config set registry https://registry.npm.taobao.org --global yarn config set disturl https://npm.</description>
    </item>
    
    <item>
      <title>在iOS11上使用自带悬浮窗工具调试UI</title>
      <link>https://wellphone.me/post/2017/use_uidebugginginformationoverlay_for_ios11/</link>
      <pubDate>Wed, 06 Dec 2017 17:15:20 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/use_uidebugginginformationoverlay_for_ios11/</guid>
      <description>背景介绍 iOS系统从9.0之后就加入了悬浮窗调试小工具来帮助开发者调试UI，很遗憾的是，这个是一个非公开的功能，苹果没有公开它的头文件。（私有API传送门）当然私有API没有阻挡住我们使用这么酷炫的小工具。如何使用可以看看前段时间笔者写过一片文章《iOS自带悬浮窗调试工具使用详解》。可是好景不长，在iOS11中这个小工具没法用了。最近想用这个系统自带的悬浮窗工具来调试UI，毕竟是接入成本最小UI调试工具，于是看到了国外大神的这篇文章 《Swizzling in iOS 11 with UIDebuggingInformationOverlay》。
原因 国外大神的文章很长，详细介绍了他是如何让悬浮窗调试工具重现在iOS11上的。文章具体内容这里就不展开了，感兴趣的可以去看看他的文章。文章主要内容：
iOS9 &amp;amp; 10 上 -[UIDebuggingInformationOverlay init] 和 [UIDebuggingInformationOverlay prepareDebuggingOverlay] 是能正常工作的。在iOS11上，上面这两个方法被苹果做了限制，只有苹果内部设备才可以正常使用。对这两个方法逆向后的代码如下：
@implementation UIDebuggingInformationOverlay - (instancetype)init { static BOOL overlayEnabled = NO; static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ overlayEnabled = UIDebuggingOverlayIsEnabled(); }); if (!overlayEnabled) { return nil; } if (self = [super init]) { [self _setWindowControlsStatusBarOrientation:NO]; } return self; } + (void)prepareDebuggingOverlay { if (_UIGetDebuggingOverlayEnabled()) { id handler = [UIDebuggingInformationOverlayInvokeGestureHandler mainHandler]; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:handler action:@selector(_handleActivationGesture:)]; [tapGesture setNumberOfTouchesRequired:2]; [tapGesture setNumberOfTapsRequired:1]; [tapGesture setDelegate:handler]; UIView *statusBarWindow = [UIApp statusBarWindow]; [statusBarWindow addGestureRecognizer:tapGesture]; } } @end  可以很清晰的看到，苹果用UIDebuggingOverlayIsEnabled() 对UIDebuggingInformationOverlay的初始化方法做了检测，如果不是内部设备就返回nil，同时对prepareDebuggingOverlay方法也做了检测。</description>
    </item>
    
    <item>
      <title>iOS纯代码编写UI工具介绍：TPLayout</title>
      <link>https://wellphone.me/post/2017/tplayout_introduce/</link>
      <pubDate>Thu, 07 Sep 2017 10:25:12 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/tplayout_introduce/</guid>
      <description>TPLayout简介 TPLayout是一个类似于Masonry的AutoLayout布局工具库。
它在github上的简介:
 TPLayout是一个轻量、快速、方便的使用代码进行UI布局的高效率工具库。TPLayout同时支持两种常见的代码布局方式，提供非常简短的方法来获取和设置Frame值；也提供了类似Masonry的链式语句的方法来设置view的约束。
 TPLayout vs Masonry, PureLayout 对于Masonry这个库大家应该都比较熟悉，就是它让大家不用去写苹果反人类的AutoLayout布局的API接口，帮助苹果普及了AutoLayout的布局方式。
对于PureLayout这个库相信应该也有大部分都知道，它将AutoLayout的接口进行了封装，也极大的方便开发者使用AutoLayout进行UI布局。
但是在使用它们的过程中，或多或少有些不方便地方。比如Masonry：
UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10); [view1 mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(superview.mas_top).with.offset(padding.top); //with is an optional semantic filler make.left.equalTo(superview.mas_left).with.offset(padding.left); make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom); make.right.equalTo(superview.mas_right).with.offset(-padding.right); }];  以上代码中，每条make开头语句实际上是一个约束；但是我们怎么获取到生成的约束的NSLayoutConstraint对象呢？完全没有办法，除非自己去遍历view的constraints属性。
mas_makeConstraints，mas_updateConstraints和mas_remakeConstraints三个方法把NSLayoutConstraint对象全隐藏起来了，开发者不能获取到每一个约束生成的NSLayoutConstraint对象。笔者觉得这个是Masonry库对开发者唯一不友好的地方。
再比如PureLayout：
NSLayoutConstraint *constraint = [view autoPinEdge:ALEdgeLeft toEdge:ALEdgeLeft ofView:otherView withOffset:10];  基本上每个语句返回NSLayoutConstraint对象，但是相对于Masonry来说少了链式语句的可读性。
TPLayout库结合了两者的优点：每条链式语句返回一个NSLayoutConstraint对象或者NSLayoutConstraint对象的数组。
总结起来，TPLayout有以下特性：
- Frame: 提供简短的方法来设置view的Frame值和两个view间的对齐关系
- AutoLayout: 通过链式语句来设置view的约束
- AutoLayout: 一条链式语句生成一个NSLayoutConstraint对象或者NSLayoutConstraint对象的数组
- AutoLayout: 可以重置、更新使用该库生成的约束
- AutoLayout: 通过NSAssert断言防止X轴Y轴方向上设置错误的约束
TPLayout使用Demo 详细的Demo
使用Frame构建UI // 设置大小 viewA.</description>
    </item>
    
    <item>
      <title>腾讯Bugly的巨坑：使用不当会造成UI界面卡死</title>
      <link>https://wellphone.me/post/2017/bugly_dispatch_once_crash/</link>
      <pubDate>Fri, 25 Aug 2017 16:52:20 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/bugly_dispatch_once_crash/</guid>
      <description>前言 Bugly和dispatch_once使用不当，会造成UI界面卡死。笔者在前段时间碰见了这样的一个卡死的情况，特意记录下来。
iOS开发者或多或少都听过或用过Bugly。它是腾讯开发的一个SDK，用来捕捉App中的crash。对于dispatch_once大家就更熟悉了，现在大部分开发者用这个来创建单例。如：
+ (SingletonA *)sharedInstance { static SingletonA *_singleton = nil; static dispatch_once_t once; dispatch_once(&amp;amp;once, ^{ _singleton = [[SingletonA alloc] init]; }); return _singleton; }  但是这两个在一起怎么会造成UI界面卡死呢？如果笔者不是亲眼所见，也不会相信Bugly会造成界面卡死。
现象 前几天碰见了这样一个情况，我们的App启动时有时候会卡在启动界面上，过一段时间 就会被系统杀掉，而且不会有Crash的堆栈。这个现象让我们开发很头疼，一旦出现就只能杀进程，重新启动App，并且还不知道是怎么回事。
调查 看到界面卡死的第一反应就是，是不是哪个地方死锁导致主线程阻塞了。使用Console.app查看App启动时的日志，没发现什么异常的情况，并且死锁这个在日志中查找起来比较麻烦。
好不容易复现这个情况后，赶紧把手机接上Mac，在Xcdoe中Attach我们App的进程，如图：
然后暂停下App进程，就可以看到当前所有线程的堆栈情况了。如图：
这下，我们才知道是卡在了dispatch_once这个地方。是我们的单例使用有问题吗？我们知道， 如果dispatch_once递归调用就会产生死锁。示例代码如下：
+ (SingletonA *)sharedInstance { static SingletonA *_singleton = nil; static dispatch_once_t once; dispatch_once(&amp;amp;once, ^{ _singleton = [[SingletonA alloc] init]; }); return _singleton; } - (instancetype)init { self = [super init]; if (self) { [self somethingInit]; // 这个方法里也调用了[SingletonA sharedInstance]，所以会产生死锁 } return self; } - (void)somethingInit { [SingletonA sharedInstance]; }  很有可能就是这个原因导致我们的App启动时卡死。于是我们开始排查dispatch_once的代码里会不会在某个条件下再次调用到相同的dispatch_once，形成递归调用，导致死锁。</description>
    </item>
    
    <item>
      <title>iOS自带悬浮窗调试工具使用详解</title>
      <link>https://wellphone.me/post/2017/use_uidebugginginformationoverlay_to_debug_ui/</link>
      <pubDate>Thu, 08 Jun 2017 09:58:10 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/use_uidebugginginformationoverlay_to_debug_ui/</guid>
      <description>12月11日更新 大家可以在这里看看如何在iOS11上使用自带的悬浮窗口调试工具：《在iOS11上使用自带悬浮窗工具调试UI》。
以下是原文 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前几天在博客上看到一篇文章《震惊！iOS 系统居然自带悬浮窗口调试工具》,看完之后笔者真就震惊了，有这样好的UI调试工具，苹果为什么不公开呢？笔者按照博文中的描述，在app中试了一下，感觉非常好用。
如何开启 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 AppDelegate 的 didFinishLaunchingWithOptions 方法中加入以下代码就可以了。
#if DEBUG id overlayClass = NSClassFromString(@&amp;quot;UIDebuggingInformationOverlay&amp;quot;); [overlayClass performSelector:NSSelectorFromString(@&amp;quot;prepareDebuggingOverlay&amp;quot;)]; #endif  运行后，用两个手指头在状态栏上同时点击下就可以显示出这个调试的悬浮层。
悬浮窗主界面 可以看到大概有这样几个选项，
 View Hierarchy（查看View的层级关系）
 VC Hierarchy（查看ViewController层级关系）
 Ivar Explorer（查看UIApplication 的成员属性）
 Measure （测量View的尺寸）
 Spec Compare （对比设计图）
  View Hierarchy &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 进入到这个页面后，可以看见整个view的层级结构。悬浮窗右上角有个Inspect，点击这个可以高亮显示当前选择的View。如图所示：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
当前选中的是 SettingSwitchItemView。
我们在页面上选择一个swicth按钮，这时会定位到该view的条目，如图所示：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
我们点击右侧的“！”图标，进入到swicth的详情页面，这里展示了view的详西信息，并且可以修改一些属性，比如我们修改这个button的透明度，如图所示：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
VC Hierarchy &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们回到悬浮窗的主界面，进入到VC Hierarchy界面看看。
这里是所有的VC的层级关系，一目了然。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
Ivar Explorer &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;接下来我们去Ivar Explorer页面看一下。进到页面后，对里面的一些值不是很熟悉，不知道是哪里的一些值，不过里面，看见了我们熟悉的 AppDelegate 。</description>
    </item>
    
    <item>
      <title>使用Interface Builder开发界面</title>
      <link>https://wellphone.me/post/2017/autolayout_demo/</link>
      <pubDate>Wed, 03 May 2017 09:51:08 +0800</pubDate>
      
      <guid>https://wellphone.me/post/2017/autolayout_demo/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前在公司内部分享会上，简单的分享了下如何使用Interface Builder开发iOS界面以及几种界面开发的方式的优缺点。写了一篇文章，现在直接把这篇文章贴到了blog上。
认识IB IB 即 Interface Builder ，是集成到Xcode上的iOS界面可视化开发工具。
功能面板  对象库面板
提供了所有Cocoa Touch 库给我们定义好的界面组件，包括 View 组件和 Controller 组件(所有名字带 xxxxController 的组件)。
对象库中组件较多，为了查找方便，底部提供了搜索栏，功能强大，一般只要输入关键的几个字母，就能快速找到你需要的组件。
 主界面
主界面提供了一个设计区域，该区域中放入我们设计的所有组件，一般要先放入一个容器组件，如：UIView 视图。然后在视图中放入其他组件。
为了快速查看主界面中相关信息，可以通过左侧的侧边栏(Desk)查看。
 属性面板
在主界面选中某个组件后，在该区域可以查看并设置组件的属性。
  示例 demo下载
 新增一个按钮
 新增一个table
 IBInspectable / IBDesignable
  Autoresizing 技术介绍 autoresizing是UIView的属性，可以用来做一些简单的自动布局实现。   属性 描述   UIViewAutoresizingNone 不会随父视图的改变而改变    UIViewAutoresizingFlexibleLeftMargin 自动调整view与父视图左边距，以保证右边距不变   UIViewAutoresizingFlexibleWidth 自动调整view的宽度，保证左边距和右边距不变    UIViewAutoresizingFlexibleRightMargin 自动调整view与父视图右边距，以保证左边距不变    UIViewAutoresizingFlexibleTopMargin 自动调整view与父视图上边距，以保证下边距不变   UIViewAutoresizingFlexibleHeight 自动调整view的高度，以保证上边距和下边距不变   UIViewAutoresizingFlexibleBottomMargin 动调整view与父视图的下边距，以保证上边距不变</description>
    </item>
    
  </channel>
</rss>
